1：基本类型
2：任意类型(不指名类型，不赋值)
3：类型推论（不指明类型，赋值）
4：联合类型   xx | xx
5：接口 ：对对象形状的描述 对类行为的抽象描述 对函数形状的描述
	可选（？）
	任意属性 （ [xxx: string] 定义了任意属性取 string 类型的值。一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集）
	只读（readonly 。只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候）
（约束对象，参数，变量）赋值变量与接口需保持一致
6：数组  type[ ]  /  Array<type>
7：函数 	函数声明（参数类型   返回值类型）          函数表达式 （  xx(参数类型）=>返回值类型 = 匿名函数声明（参数类型   返回值类型））
（区分es6的 =>）（含可选参数 。TypeScript 会将添加了默认值的参数识别为可选参数，不受「可选参数必须接在必需参数后面」的限制）
（重载）
8：类型断言 （类型断言）（<类型>值   /   值 as 类型）
9：文件声明
10：内置对象（es:Boolean、Error、Date、RegExp）
16：类型别名 （type xxx='type' ）	   字符串字面量类型  （type EventNames = 'click' | 'scroll' | 'mousemove';）
11：元组：宽松数组  （当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：）
12：枚举 （枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：）
（枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：）
（常数枚举是使用 const enum 定义的枚举类型：常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员）
（外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型：）
13：类
	类(Class)：定义了一件事物的抽象特点，包含它的属性和方法
	对象（Object）：类的实例，通过 new 生成
	面向对象（OOP）的三大特性：封装、继承、多态
	封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
	继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
	多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat
	存取器（getter & setter）：用以改变属性的读取和赋值行为
	修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法
	抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
	接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口
ty: 修饰符：public、private 和 protected
	抽象类：abstract
	类的类型
14：接口  interface   对对象形状的描述 对类行为的抽象描述  对函数形状的描述  接口的实现（implements）  接口可以继承接口和类
15：泛型  泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。<T U>    泛型约束  泛型参数的默认类型
17：声明合并 如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型  （合并的属性的类型必须是唯一的）
